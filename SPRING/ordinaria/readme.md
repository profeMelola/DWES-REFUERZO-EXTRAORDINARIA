# Prueba individual evaluable de Spring 

Todos los endpoints son públicos. Si tenéis problemas para configurar la SEGURIDAD, dejadlos públicos.

**USUARIOS DE PRUEBA** (login y pwd iguales): admin, staff, billing

## Modelo completo del dominio

![alt text](image.png)

## 1. ENTIDADES JPA

Debes diseñar correctamente las relaciones bidireccionales JPA junto con los métodos java correspondientes, entre Doctor y DoctorSpecialty. 

CORRIGE los errores JPA. Haz la VALIDACIÓN.

```
CREATE TABLE doctors (
                         id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                         license_number VARCHAR(40) NOT NULL,
                         full_name VARCHAR(120) NOT NULL,
                         email VARCHAR(150) NOT NULL,
                         active BOOLEAN NOT NULL
);

CREATE UNIQUE INDEX uk_doctor_license ON doctors(license_number);

-- -------------------------
-- DOCTOR_SPECIALTIES (entity intermedia con PK compuesta)
-- PK: (doctor_id, specialty)
-- -------------------------
CREATE TABLE doctor_specialties (
                                    doctor_id BIGINT NOT NULL,
                                    specialty VARCHAR(30) NOT NULL,
                                    level VARCHAR(20) NOT NULL,
                                    active BOOLEAN NOT NULL,
                                    since_date DATE NOT NULL,
                                    consultation_fee_override DECIMAL(12,2),

                                    CONSTRAINT pk_doctor_specialties PRIMARY KEY (doctor_id, specialty),
                                    CONSTRAINT fk_doctor_specialties_doctor
                                        FOREIGN KEY (doctor_id) REFERENCES doctors(id)
);
```

## 2. EMITIR FACTURA DE UNA CITA (crear Invoice + líneas)

```
POST http://localhost:8083/api/appointments/{id}/invoice
```

Crear factura a partir de una cita y sus servicios médicos. 

La creación de la factura y sus líneas debe ser atómica  (Prueba con la cita con id 56)



Parte de *InvoiceController* y ve completando los fuentes pertienentes. Completa, no machaques.

La factura debe persistirse junto con todas sus líneas en la base de datos en la misma operación. Mantener bidireccionalidad.

**Seguridad:** El usuario solo con rol ADMIN o BILLING. 


1. No puede haber servicios duplicados en el json request; si no → BadRequestException (400)
2. La cita debe existir; si no → NotFoundException (404).
3. La cita no puede estar ya facturada; si no → ConflictException (409). 
4. La cita no puede estar CANCELLED. si no → BussinessRuleException (422).
5. La cita debe estar COMPLETED si no → BussinessRuleException (422).
6. Cada medicalServiceId debe existir y estar active=true; si no: inexistente → 404 / inactivo → 422 (el primero que falle)
7. Las líneas de factura se emitirán sin aplicar ningún tipo de descuento.
8. El tipo de IVA aplicado en las líneas de factura será siempre del 21% (VAT_21). El cálculo de impuestos y totales debe realizarse en el servidor.
9. Los importes económicos deberán redondearse a dos decimales siguiendo el redondeo estándar.


### Request

![alt text](image-1.png)

### Response

![alt text](image-2.png)

### Ejemplos de respuestas con error (Obligatorio completar y usar ApiErrorResponse)

![alt text](image-3.png)

### MEJORAS/AMPLIACIONES EXTRAORDINARIA

<img width="150" height="150" alt="Licencia de Flaticon" src="https://github.com/user-attachments/assets/ffd7778e-7786-47a5-94c0-53554ebdf584" />

1. Reportar todos los duplicados detectados (no solo el primero)
2. IVA Por servicio: cada MedicalService tiene su VatRate (o vatPercent), no fijo 21%.
3. Decuento real: si el paciente tiene hasInsurance=true → aplicar DiscountType.INSURANCE_20 (20% sobre base, antes de IVA)
4. Validación por límites: no permitir qty <= 0 ni qty > 20
5. Reglas: máximo 10 líneas por factura.
6. Errores con i18n: todos los mensajes de excepción deben venir de messages.properties (o al menos mensajes constantes)

---

## 3. INFORME DE SERVICIOS MÁS FACTURADOS

```
GET /api/reports/top-services
```

Endpoint de reporting que devuelve un ranking PAGINADO de los servicios médicos más facturados en un intervalo de tiempo, filtrando por la fecha de emisión de la factura.

COMPLETA LAS CLASES QUE SE PROPORCIONAN:

- ReportController
- ReportService
- TopServiceReport(mantén campos acorde captura)
- InvoiceLineRepository
  
La solución debe usar JPQL con proyección a DTO. (joins + group by + agregaciones)

El filtro se hace por factura, no por cita (Invoice.issuedAt)

- from (obligatorio) → fecha/hora mínima (incluida).
- to (obligatorio) → fecha/hora máxima (incluida).
- status (opcional) → si se informa, solo se consideran facturas con ese estado.
- Solo acceso usuario con rol BILLING.
- El ranking se calcula solo con facturas emitidas (issuedAt != null) en el rango de fechas.
- Los servicios más facturados deben aparecer primero (importe total facturado).

  
Como resultado debe devolverse una lista del DTO TopServiceReport, con estos campos:
- serviceId: id del servicio
- serviceName: nombre del servicio
- linesCount: número de líneas de factura asociadas al servicio
- unitsSold:unidades totales vendidas del servicio
- totalBilled: importe total facturado del servicio
  
El número máximo de resultados lo marca el tamaño de la paginación:por defecto 3, mínimo 1, máximo 5


### Pasos para su resolución

1. ¿Qué filas quiero devolver? Un ranking de servicios. Una fila =  1 servicio
2. ¿Qué entidad representa "una venta de un servicio"?
3. Elige el FROM correcto. Los agregados salen de la entidad elegida en el from.
4. Filtros. Pon el where correctamente.
5. ¿Qué significa "más facturados"? Hablamos del order by.
6. Proyección a DTO (constructor expression)

```
FROM: __

JOINs: __, __

WHERE: issuedAt != null, rango, status opcional

GROUP BY: __

ORDER BY: __ desc

SELECT DTO
```
